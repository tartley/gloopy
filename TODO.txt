
Next
----

* modifier to extrude faces of a given shape
    (this could form a possible source for tweening data)

* keypresses should map to invocation of a callable.
    * keys to zoom camera orbit in and out
    * callables to grow or shrink an object

* Add good shapes from flyinghigh


Demos
-----

* alt-add puts new object in orbit around selected item
* Callables to put an object in orbit around another object
* Callables to change orbital parameters
    - of camera
    - of selected object
* User-controlled camera.
* Display a cursor on currently selected item, tab changes selected
  item, callables modify this item

* demo attaching point light source to position of gameitem

* use newtonian update on every item. Use calculated forces to produce
  orbits. Keys to add repulsive fields or similar?

* Interpenetrating cuboid solids and voids. (& rooms, a void in a solid)


Geometry
--------


* polyhedra bevel

* add proper centroid method to face
  use it in stellate and subdivided

* face labelling:

    * label each face with a 'generation' count? Or a 'face type' UID, so that
      modifications could operate on just a subset of faces.
      * UID is bad because how to subsequent operations know which UID to
        operate on?
      * generation count is bad because subsequent operations could create#
        identical counts on very different faces
      * maybe each face has a list of operations that have been performed on it

        Tetrahedron:
            f0 [tetrahedron]
            f1 [tetrahedron]
            f2 [tetrahedron]
            f3 [tetrahedron]

        subdivide:
            f0.0 [tetrahedron,center]
            f0.1 [tetrahedron,corner]
            f0.2 [tetrahedron,corner]
            f0.3 [tetrahedron,corner]
            f1.0 [tetrahedron,center]
            f1.1 [tetrahedron,corner]
            f1.1 [tetrahedron,corner]
            f1.1 [tetrahedron,corner]
            etc

    * add shape modifiers that subdivide, then operate on just a subset of the
      new faces. Recreate Koche tetra using this.
    * Callables to change the colors which use labelled faces
        * different colors for different labels
        * subdivided center inverse from subdivided corners
          but adjacent subdivided surfaces should be the opposite,
          so that every new face is surrounded by its inverse

* proper edge modelling:

    * subdivide adds more vertices than it needs to: two at the midpoint of each
      edge (one for each adjacent face.)

    I fear edge modelling will not provide the ordering info required by the
    following two:

    * subdivide should work on faces with any number of edges.
      leave same shape as original in middle, surround it with triangles from
      cutting off each corner

    * function to truncate a shape by amount from 0 to 1. Truncation by 1
      results in the geometric dual. This is half done, but turns out to be a
      bit hard, because we don't know precisely what order to add the
      newly-generated vertices.

* 2D poly extruder
* 2D poly into ring
* interlinked rings. knots.

* close-packed cube patterns, specified as tuple ordinates, eliminating
  faces of cubes which abut.
* Tetris shapes
* Cube cluster generated from pixels of small bitmaps. Invader! Mario! etc.

complicated saddle surfaces with holes:
http://www.cs.berkeley.edu/~sequin/SCULPTS/scherk.html

building skyline at night:
http://www.openbusiness.cc/wp-content/uploads/hk1.jpg

bulbous blobs with holes
http://www.cs.berkeley.edu/~sequin/MVS/index.html
http://www.graphica.com/gallery/trott1.html

Sections of a sphere:
http://www.cs.berkeley.edu/~sequin/ART/MaxBill/MBTy5.jpg


Rendering
---------

* Curved surfaces: Expressed in shape as a collection of faces. Verts for all
  faces within the collection are shared, not duplicated from one face to the
  next, and normals for each vertex are interpolated between surface normal for
  each adjacent participating face. Assume colors are fixed across the whole
  surface?

* better shaders:
    * ambient light level should be a uniform
    * demo should populate this using world.background_color
    * directional light position should be a uniform
    * directional light color should be a uniform
    * point light source position should be a uniform
    * point light source color should be a uniform
    * specular highlights from directional light
    * specular highlights from point light
    * demo should include a moving object that acts as point light source
    * per pixel lighting so that specular highlights in middle of flat faces
      look good
    * Textures. See:
      http://www.lighthouse3d.com/opengl/glsl/index.php?textureComb
    * if skybox is drawn, demo should draw a 'sun' or 'moon' or somesuch
      in direction of directional light source

* Allow each gameitem to specify its own shader program

* scale movement by mean dt over last few frames to reduce jittery movement
  caused by isolated slow or fast frames.

* anti-alias. Use multisampling. Expose as option to application.


Animation
---------

* Add uniform to tween between two models
* use tweening to animate creation of a bevel
* use tweening to animate forming a polyhedra's dual

* Add to geometry while it is being displayed
    * recreate it from scratch? Or modify (& grow) existing vertex array?
    * colors too
    * Squaresnake



Infrastructure
--------------

* pyglet latest from hg
* Python 3

* log file should be created in app_root if possible, or else in
  application's scratch space, not cwd

* Convert options to use argparse, so that it can provide command line usage
* command-line option to select screen resolution on startup
* restore desktop resolution on exit
* keys or something to select new screen resolution during runtime
* persist options to store user's chosen screen resolution

* should be pip installable, and doing so should install its deps
* examples should be installed into site-packages
* Check that examples work in isolation, using an installed version of gloopy
* source install should be 'install python; pip install gloopy'
* generate sphinx documentation
* fill in doc strings
* make 0.1 release on cheese shop


OpenGL 3
--------

* VBO the index array
  Can this go into same vertex array object?

* instead of setting modelview using glMultMatrix, we should be passing in
  object matrix (or position, orientation) using vertex shader uniforms.
  Review Mike's 'canonical opengl3 application', from his old pycon talk.
  try OpenGL.FORWARD_COMPATIBLE_ONLY = True
  see http://pyopengl.sourceforge.net/documentation/deprecations.html
  Does this still work ok on opengl 2.1?
  Does this affect performance?
  Same for projection matrix?


Startup Performance
-------------------

* Startup: Replace the (* seq) operator on initialising gl_array in Glyph.
  Instead use:
    array = arraytype()
    array[:] = seq # eg. [11, 22, 33... ]

* Combining the orientations of nested multishapes is done in an innefficient
  manner, multiplying every vertex by each multishape's orientation in
  series. Modify to calculate the cumulative orientation first, then
  multiply each vertex by the result.

* totally rewrite shape_to_glyph algorithm, incorporating what Glyph then
  subsequently does with the outputs. Suspect we're
  doing too much work (e.g. vertex and index re-ordering)

- check a profiler


Render Performance
------------------

* split performance demo into a) performance and b) twister

- create a matrix object which combines all the methods of Vector
  and orientation and which outputs a matrix which can be fed directly to
  shader 'modelview' uniform
    - read this guy's Cython-howto tutorial:
      https://github.com/ricardodelnero/small-Cython-How-To
- Cython the render loop

* Pass an array of gameitem positions & orientations directly to the shaders,
  perhaps as a float texture. Add an integer vertex attribute to say which
  gameitem the vertex belongs to (i.e. an index into the image array.) There
  is then no need to update modelview between draw calls. Do the same with
  orientation, and then all objects could be drawn with a single glDraw call.
OR
* try an entirely CPU based solution. Calc vertex array positions using Cython
  accel arithmetic, then render all using single glDraw.


Design
------

* render should maybe specialise as 'RenderGlyphs' - take list of glyphs,
  positions, orientations (or glyphs, matrices) instead of needing access to
  world or items?
* consider eliminating class Gloopy. Expose world, camera, etc to user.
  Functionality provided by gloopy becomes the canonical demo script.
* eventloop in top level package? render? world? camera? what else?
* Also, euclid contains Matrix.new_look_at - could this replace some of
  current camera or projection code?
* Review whether gloopy should be broken into separate libraries:
    - rendering: should know nothing of shapes or world.
        passed a list of (glyph, pos&orientation)
    - shape: polyhedra to glyphs
    - eventloop. Ties it together by:
        -scheduling calls to world.update
        -scheduling calls to render.draw
        -creating iterator over world.items.glyphs (etc) to pass
         to render.draw
    - shaders (compiling, linking, binding, and provided shaders)
* user should (can?) provide a world update function?
* Orbit, Newtonion should maybe act functionally, return a new value 
  instead of attempting to set one? Then update() (or world.update)
  becomes:
    position = self.move()
* newtonian movement should be provided as a public callable to either:
    - be called for one item, AS its update method
    - be called for one item, FROM its update method.
    - be called for all items, from world.update


Talk Outline
------------

* Inspirations - Effective non-photo-realistic work in gaming, movies and the
  demo scene. (1m)
* A convenient & Pythonic way to model 3D polyhedra, and some neat generators
  to convert these into OpenGL arrays at runtime. (7m)
* Algorithmic modification of shapes, such as bevels, geometric duals, and
  polyhedron stellation. (2m)
* The resulting performance characteristics: What works well from Python, and
  what doesn't. (2m)
* Composition of polyhedra to create more complex shapes (3m)
* Koch tetrahedron & tetrix, aka Sierpinski tetrahedron. (1m)
* Surprisingly effective 3D models created from small bitmaps. (1m)
* Automatic generation of trees, mazes, complex spaces. (3m)
* Shapes that morph: Rearranging vertices on the fly (5m)
* Questions (5m)


Ideas for later
---------------

* Fake skybox geometry:
    * vector:
        * triangular stars
        * a ground, with mountains! and moon
        * animate: sky changes color, moon moves
        * A sun! * moon has rings!
    * a real bitmap skybox thing
    * stack skyboxes, so that bitmap background has ground & mountains
      overlaid. Or sky background has ground overlaid.
    * (if bitmaps can contain alpha, then they can usefully overlay too.
      eg. big planet from UT skyboxes)

* In game text:
    for HUD
    for MENUS, instructions
    as bitmaps on shapes
* Allow items to toggle between being mobile (with a position)
  and 'static', which draws them as part of the 'world' render call
* triangulation for convex faces
* shadows
* Introduce a variable to control the use of primitives other than
  GL_TRIANGLES. When using GL_TRIANGLE_FAN or _STRIP, draw all the
  discontinuous faces of a single shape in a single draw call, using:
    glEnable( GL_PRIMITIVE_RESTART )
    glPrimitiveRestartIndex( MAXINT ) # for eg
  and then insert indices of value MAXINT into the index array to form a
  break between strips. Bear in mind this is meant to be a space & time
  optimisation, so measure the latter before deciding the keep it.
* Curved surfaces (i.e. re-use same vertex (incl. normals) between adjacent
  triangles):
    * Cylinder * sphere * Ring (hollow cylinder) * donut * ring with crosses
* Generate equipotential surfaces in scalar fields
* Use that to generate cool organic shapes with holes,
  eg. see screenshots on the geexlab website
* Noise shaders
* Geometry instancing, see techniques enumerated here:
  http://www.geeks3d.com/20100629/test-opengl-geometry-instancing-geforce-gtx-480-vs-radeon-hd-5870/
* Try enabling gamma correction using: glEnable(GL_FRAMEBUFFER_SRGB)
  This can make a huge difference to the results of lighting
* 2D mode, with ortho projection and 2D verts
* orbit should have an option to face in particular direction during orbit,
  i.e. in direction of motion, or toward rotated body. Presumably expressing
  this as a Q relative to direction of motion makes sense.
* assigning orbit should not move the object discontinuously, but should
  smoothly interpolate from initial position
  (interpolate not quite right - might result in reversal of direction
  towards the end. How to generate a feasible-looking orbital insertion?)
* how to generalise the above for all movers?


DONE

* delete bits of pyweek11 game that aren't required by gloopy,
* move required bits of pyweek11 specific functionality out to demo.py
* presumably glooby, as a library, should not have a main.py
* move stuff out of demo.py into new gloopy.init()
* creation of cube and a non-default sky color should be done by demo.py
* Named colors: use the xkcd database, as staticmethods on Color
* Eventloop knows about many unrelated things
* Log the version number of gloopy
* Log opengl info
* Log options
* Gameitem orientations
* Gameitem spinners
* Gameitem movement
* measure performance - doesn't look like we're getting 60fps
* camera in wobblyorbit
* changes to euclid: Are there tests to guaruantee behaviour is preserved? Y.
* camera should not be attribute of eventloop.
* make sure all access to pyeuclid is using the local copy.
* any_orthogonal has a bug if given vector is negative y axis.
    Should set friend as:
    'x_axis if abs(x) < abs(y) or abs(x) < abs(z)) else y_axis
* current diffs cause slowdown because of __setattr__ on gameitem. (measure
  to confirm this) Fix might be to explicitly pass 'item' to item.update,
  in world.update, so that orbits, etc would no longer need to have their
  own reference to their parent gameitem.
* orbit center should accept either a location or a gameitem.

* try using pyopengl bindings with pyopengl-accelerate added
  (10%, ie 2fps. meh)
* add pyopengl performance fixes (no bloody difference.)
* figure out difference between pyglet.gl and pyglet.gl.gl 
  (former includes glu, glext_arb, etc)
* make it easy to switch between pyglet.gl and pyopengl (bool in util.gl)

* f12 to toggle fps
* alt-enter to toggle fullscreen

* code from old europython talk does 450 independant cubes at 60fps.
  we can only do 100. wtf? Reason is the code in middle of render loop
  which handles position and orientations. Every frame it was creating new
  euclid.Matrix, offsetting it, rotating it, and worst of all, then ctypesing
  it to pass to glMatrixMult.
* repeatable performance test one or more new demo.py scripts:
    512 cube shaped gameitems, unique positions, unique glyphs, FPS:
     23: no orientations
     19: no orientations, newtonian update, with acc, with vel
     16: with orientations
     12: with orientations, newtonian update, with acc, with vel, with ang_vel
* Review TODO doc from 'flyinghigh opengl from python' talk
* Review TODO doc from 'pyweek11'
- position as vector
* revert quaternions to better API and more understandable implementation using
  3-axis
- pass glMultMatrix a matrix constructed from position and orientation
* remove utils.gl. Modules should just use OpenGL.GL or pyglet.gl as they
  please
* create 'pyls' script to aid refactoring
* combine vertex, color, normals into single interleaved array,
* switch from vertex arrays to VBO objects
* move from using glVertexPointer, glColorPointer, glNormalPointer to using
  glVertexAttributePointer
* use vertex array object to reduce number of bind calls needed in inner
  render loop.
* Can binding the VBO itself go into the vertex array object? Y.
* use pyopengl shader management instead of our own compile/link code.
  Or improve our own shader management code to take uniforms, see:
    http://swiftcoder.wordpress.com/2008/12/19/simple-glsl-wrapper-for-pyglet/
* color in top level package
* add an example which allows browsing of a bestiary
* the regular solids
* try subdividing shapes with a new vertex in the middle of the face
* function to stellate a shape (either strict stellation, or else just replace
  each face with a pointy thing. The second seems both easier and more
  flexible - pointy could be varied in height, even made negative.
  (REPLACE the current subdivide_center with this - it is of little use for
  iterated application)
* decide what to do about uniformly dark faces on opposite side of polyhedra
  to the directional light source
* keypresses should map to invocation of a callable.
    * Callables to create basic shapes and add them to the world
    * Callables to modify the shape of the last-added item
        * subdivide, etc
    * Callables to change the colors
        * one random color all over
        * different random color for each face
* normalise the sizes of the basic shapes to all have verts at the given
  radius

