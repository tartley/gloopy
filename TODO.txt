
FEATURES

PERFORMANCE

* Store item positions and orientations as numpy vectors or matrices.
* cache resulting matrix for objects which haven't moved / rotated since
  last frame. Hackery implies we'll get 54/sushik 80/jlappy fps for this,
  with orientations but without Newtonian updates.
* store all positions and orientations in a big array, and perform
  newtonian updates as a single numpy operation. Hopefully cost of
  newtonian updates will then be low.
* combine vertex, color, normals into single array, to reduce number of
  glXPointer calls in the inner render loop. (hackery to simulate this
  (move glColorPointer, glNormalPointer outside main render loop) suggests
  from 54 to 73 fps improvement.
* pass array of pos/orientation matrices to opengl (in a texture?) and let
  shaders mult each vertex position by correct element from this array.
  Need to add integer vertex attribute indicating which element to use.
  Then can remove glMultMatrix call from inner render loop.
  Then can stop iterating over items in inner render loop - just call
  glDrawElements once on a huge array of all vertices in the world.


DESIGN

* Orbit, Newtonion should maybe act functionally, return a new value 
  instead of attempting to set one? Then update() (or world.update)
  becomes:
    position = self.move()

* use pyopengl shader management
* use pyopengl VBO objects

* user should provide a world update function?
* newtonian movement should be provided automatically by world.update?

* render should maybe specialise as 'RenderWorld' - should take list of glyphs,
  positions, orientations (or glyphs, matrices) instead of needing access to
  world?
* consider eliminating class Gloopy. Expose world, camera, etc to user.
  Functionality provided by gloopy becomes the canonical demo script.
* eventloop in top level package?
* color in top level package?
* render? world? camera? what else?
* Put demo.py in 'examples' dir
* Also, euclid contains Matrix4.new_look_at - could this replace some of
  current camera or projection code?
* Either provide friendly wrapper for quaternions-as-orientation, or revert
  to much better API and more understandable implementation using three
  axes.
* Dependencies should be in a virtualenv. Put virtualenv creation script,
  or 'frozen' version number output, into hg
* Euclid should be a virtualenv installed dependency, not bundled.
  (& then remove path.append in demo.py)
* should be pip installable, and doing so should install its deps
* Check that demo.py works in isolation, using an installed version of gloopy
* Consider getting pyglet latest svn

* Add all good shapes from previous programs
* demo.py should create a more funky shape
* Convert options to use argparse, so that it can provide command line usage

* generate sphinx documentation
* fill in doc strings
* make 0.1 release on cheese shop

AFTER 0.1 RELEASE ------------------------------------------------------------

* Review TODO docs from 'pyweek11' and 'hobbyist opengl' talk, transfer
  good parts into this document
* Review whether gloopy should be broken into separate libraries:
    - rendering: should know nothing of world.
        passed a list of (glyph, orientation)
        later extend this to (glyph, state, orientation), where state
        encapsualtes things like enabling shaders, etc, and renders are
        sorted to group similar states.
    - shape: geometry and glyph generation
    - eventloop. Ties it together by:
        -scheduling calls to world.update
        -scheduling calls to render.draw
        -creating iterator over world.items.glyphs (etc) to pass
         to render.draw

* scale movement by mean dt over last few frames to reduce jittery movement
  caused by isolated slow or fast frames.

* better shaders: incorporate the lighting shaders from pyopengl tutorials,
  and provide a class which binds named uniforms to instance attributes
  or somesuch. Does pyopengl already have such a class?

* Combining the orientations of nested multishapes is done in an innefficient
  manner, multiplying every vertex by each multishape's orientation in
  series. Modify to calculate the cumulative orientation first, then
  multiply each vertex by the result.
* Introduce a variable to control the use of primitives other than
  GL_TRIANGLES. When using GL_TRIANGLE_FAN or _STRIP, draw all the
  discontinuous faces of a single shape in a single draw call, using:
    glEnable( GL_PRIMITIVE_RESTART )
    glPrimitiveRestartIndex( MAXINT ) # for eg
  and then insert indices of value MAXINT into the index array to form a
  break between strips. Bear in mind this is meant to be a space & time
  optimisation, so measure the latter before deciding the keep it.
* log gloopy version number should include hg revision?
* log file should be created in app_root if possible, or else in
  application's scratch space, not cwd

* command-line option to select screen resolution on startup
* keys or something to select new screen resolution during runtime
* persist options to store user's chosen screen resolution

* Control over ambient and directional light sources
* Point light sources
* Textures

* Start work on the pycon talk demo that will be produced using gloopy
  How about the polyhedran face-extruder?
* Use gloopy to implement the original vision for pyweek11CubeCaught

* anti-alias. Use multisampling. Expose as option to application.
* orbit should have an option to face in particular direction during orbit,
  i.e. in direction of motion, or toward rotated body. Presumably expressing
  this as a Q relative to direction of motion makes sense.
* assigning orbit should not move the object discontinuously, but should
  smoothly interpolate from initial position
  (interpolate not quite right - might result in reversal of direction
  towards the end. How to generate a feasible-looking orbital insertion?)
* how to generalise the above for all movers?
* how to use a mover both as an update function, and call one from an update
  function?


PERFORMANCE ------------------------------------------------------------------

* Pass an array of gameitem positions directly to the shaders. Add an integer
  vertex attribute to say which gameitem the vertex belongs to (i.e. an index
  into the gameitem positions array.) There is then no need to update
  modelview between draw calls. Do the same with orientation, and then all
  objects could be drawn with a single glDraw call.
* Use numpy to add an array of velocities to the array of positions every
  frame. Also possibly add an array of accellerations.
  Python code would just make update occasional
  impulses into the accel or velocity arrays.
* Cython the inner render loop?


IDEAS FOR LATER --------------------------------------------------------------

* Curved surfaces (i.e. re-use same vertex (incl. normals) between adjacent
  triangles)
* Generate equipotential surfaces in scalar fields
* Use that to generate cool organic shapes with holes,
  eg. see screenshots on the geexlab website
* Noise shaders
* Geometry instancing, see techniques enumerated here:
  http://www.geeks3d.com/20100629/test-opengl-geometry-instancing-geforce-gtx-480-vs-radeon-hd-5870/
* Try enabling gamma correction using: glEnable(GL_FRAMEBUFFER_SRGB)
  This can make a huge difference to the results of lighting
* 2D mode, with ortho projection and 2D verts


WON'T DO ---------------------------------------------------------------------

* kwargs to gameitem constructor should convert tuples to quaternions
    - I don't think manually constructing Q's is useful. Use the Q static
      methods instead


DONE -------------------------------------------------------------------------

* delete bits of pyweek11 game that aren't required by gloopy,
* move required bits of pyweek11 specific functionality out to demo.py
* presumably glooby, as a library, should not have a main.py
* move stuff out of demo.py into new gloopy.init()
* creation of cube and a non-default sky color should be done by demo.py
* Named colors: use the xkcd database, as staticmethods on Color
* Eventloop knows about many unrelated things
* Log the version number of gloopy
* Log opengl info
* Log options
* Gameitem orientations
* Gameitem spinners
* Gameitem movement
* measure performance - doesn't look like we're getting 60fps
* camera in wobblyorbit
* changes to euclid: Are there tests to guaruantee behaviour is preserved? Y.
* camera should not be attribute of eventloop.
* make sure all access to pyeuclid is using the local copy.
* any_orthogonal has a bug if given vector is negative y axis.
    Should set friend as:
    'x_axis if abs(x) < abs(y) or abs(x) < abs(z)) else y_axis
* current diffs cause slowdown because of __setattr__ on gameitem. (measure
  to confirm this) Fix might be to explicitly pass 'item' to item.update,
  in world.update, so that orbits, etc would no longer need to have their
  own reference to their parent gameitem.
* orbit center should accept either a location or a gameitem.

* try using pyopengl bindings with pyopengl-accelerate added
  (10%, ie 2fps. meh)
* add pyopengl performance fixes (no bloody difference.)
* figure out difference between pyglet.gl and pyglet.gl.gl 
  (former includes glu, glext_arb, etc)
* make it easy to switch between pyglet.gl and pyopengl (bool in util.gl)

* f12 to toggle fps
* alt-enter to toggle fullscreen

* code from old europython talk does 450 independant cubes at 60fps.
  we can only do 100. wtf? Reason is the code in middle of render loop
  which handles position and orientations. Every frame it was creating new
  euclid.Matrix4, offsetting it, rotating it, and worst of all, then ctypesing
  it to pass to glMatrixMult.

* repeatable performance test one or more new demo.py scripts:
    512 cube shaped gameitems, unique positions, unique glyphs, FPS:
     23: no orientations
     19: no orientations, newtonian update, with acc, with vel
     16: with orientations
     12: with orientations, newtonian update, with acc, with vel, with ang_vel

