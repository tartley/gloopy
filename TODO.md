# Tidying

- Delete examples that do not work.
- Tidy the changes from pyMNtos
    (one of the new features I thought was coded foolishly)
- Update to pyopengl3.1 (requires new approach to buffers or something)
- faces, instead of having integer attributes, should be grouped into
  a set of sets, or something. This actually lends itself to adding
  transparent stuff later.
- MANIFEST.in should be generated by setup.py
- space invaders show seam glitches (remove size mults to fix this and
  to understand how it was introduced)

- Consider eliminating the ability to modify shapes in-place, especially since
  this doesn't play nice with multishapes generator properties.
- if same shape is assigned to many items, it gets a separate glyph in each
  case. glyphs should not be stored as attribute of item. They should be
  stored in the view, in a dictionary of {shape_id: glyph}.
* Try enabling gamma correction using: glEnable(GL_FRAMEBUFFER_SRGB)
  This can make a huge difference to the results of lighting
* Allow items to specify being mobile (with a position)
  and 'static', which draws them as part of the 'world' render call
* triangulation for convex faces
* shadows
- When an in-world item is assigned a new shape, or when a shape is modified,
  it should fire an event that causes the corresponding glyph to be regenerated.

# Inspiration

complicated saddle surfaces with holes:
http://www.cs.berkeley.edu/~sequin/SCULPTS/scherk.html

building skyline at night:
http://www.openbusiness.cc/wp-content/uploads/hk1.jpg

bulbous blobs with holes
http://www.cs.berkeley.edu/~sequin/MVS/index.html
http://www.graphica.com/gallery/trott1.html

Sections of a sphere:
http://www.cs.berkeley.edu/~sequin/ART/MaxBill/MBTy5.jpg

screenshots on the geexlab website

Seirpinky cubes with floating debris:
http://www.youtube.com/user/xenopusRTRT#p/u/2/SDzZchuhECY

# Rendering

* better shaders:
    * ambient light level should be a uniform
        * demo should populate this using world.background_color
    * directional light position & color should be uniforms
        * demo should assign these
    * point light source position & color should be uniforms
        * demo should attach point light source to a moving item
    * specular highlights from directional light
    * specular highlights from point light
    * per pixel lighting so that specular highlights in middle of flat faces
      look good
    * Textures. See:
      http://www.lighthouse3d.com/opengl/glsl/index.php?textureComb
    * demo should draw a 'sun' or 'moon' or somesuch
      in direction of directional light source

* fix your timestep. In particular, some way to reduce jittery movement
  caused by isolated slow or fast frames.

# Documentation

* sdist documentation images are included twice
* sdist documentation should not be in html subdir
* documentation should not include test packages
* pip install should install deps, e.g. pyglet, popengl
* Readme cannot contain class links, but we'd like the intro.rst (derived
  from it) to do so. Some sort of copy with a search-and-replace?

# Screen resolution

* key to flip from one screen to another when fullscreen
* Convert options to use argparse, so that it can provide command line usage
* command-line option to select screen resolution on startup (if used, then
  restore desktop resolution on exit)
* keys or something to select new screen resolution during runtime
* persist user's chosen screen resolution

# OpenGL 3

* VBO the index array
  Can this go into same vertex array object?
* instead of setting modelview using glMultMatrix, we should be passing in
  object matrix (or position, orientation) using vertex shader uniforms.
  Review Mike's 'canonical opengl3 application', from his old pycon talk.
  try OpenGL.FORWARD_COMPATIBLE_ONLY = True
  see http://pyopengl.sourceforge.net/documentation/deprecations.html
  Does this affect performance?
  Same for projection matrix?

# Performance

- create a matrix object which combines all the methods of Vector
  and orientation and which outputs a matrix which can be fed directly to
  glMatrixMult or a shader 'modelview' uniform
    - read this guy's Cython-howto tutorial:
      https://github.com/ricardodelnero/small-Cython-How-To
- Cython the matrix and the inner render loop
- Pass an array of gameitem positions & orientations directly to the shaders,
  perhaps as a float texture. Add an integer vertex attribute to say which
  gameitem the vertex belongs to (i.e. an index into the image array.) There
  is then no need to update modelview between draw calls. Do the same with
  orientation, and then all objects could be drawn with a single glDraw call.
  (downside is it needs modified entries in array of pos/orientation matrices
  sending to GPU every frame, but even the entire array would be smaller than
  the scene geometry)

# DONE

* delete bits of pyweek11 game that aren't required by gloopy,
* move required bits of pyweek11 specific functionality out to demo.py
* presumably glooby, as a library, should not have a main.py
* move stuff out of demo.py into new gloopy.init()
* creation of cube and a non-default sky color should be done by demo.py
* Named colors: use the xkcd database, as staticmethods on Color
* Eventloop knows about many unrelated things
* Log the version number of gloopy
* Log opengl info
* Log options
* Gameitem orientations
* Gameitem spinners
* Gameitem movement
* measure performance - doesn't look like we're getting 60fps
* camera in wobblyorbit
* changes to euclid: Are there tests to guaruantee behaviour is preserved? Y.
* camera should not be attribute of eventloop.
* make sure all access to pyeuclid is using the local copy.
* any_orthogonal has a bug if given vector is negative y axis.
    Should set friend as:
    'Vector.x_axis if abs(x) < abs(y) or abs(x) < abs(z)) else Vector.y_axis
* current diffs cause slowdown because of __setattr__ on gameitem. (measure
  to confirm this) Fix might be to explicitly pass 'item' to item.update,
  in world.update, so that orbits, etc would no longer need to have their
  own reference to their parent gameitem.
* orbit center should accept either a location or a gameitem.

* try using pyopengl bindings with pyopengl-accelerate added
  (10%, ie 2fps. meh)
* add pyopengl performance fixes (no bloody difference.)
* figure out difference between pyglet.gl and pyglet.gl.gl 
  (former includes glu, glext_arb, etc)
* make it easy to switch between pyglet.gl and pyopengl (bool in util.gl)

* f12 to toggle fps
* alt-enter to toggle fullscreen

* code from old europython talk does 450 independant cubes at 60fps.
  we can only do 100. wtf? Reason is the code in middle of render loop
  which handles position and orientations. Every frame it was creating new
  euclid.Matrix, offsetting it, rotating it, and worst of all, then ctypesing
  it to pass to glMatrixMult.
* repeatable performance test one or more new demo.py scripts:
    512 cube shaped gameitems, unique positions, unique glyphs, FPS:
     23: no orientations
     19: no orientations, newtonian update, with acc, with vel
     16: with orientations
     12: with orientations, newtonian update, with acc, with vel, with ang_vel
* Review TODO doc from 'flyinghigh opengl from python' talk
* Review TODO doc from 'pyweek11'
- position as vector
* revert quaternions to better API and more understandable implementation using
  3-axis
- pass glMultMatrix a matrix constructed from position and orientation
* remove utils.gl. Modules should just use OpenGL.GL or pyglet.gl as they
  please
* create 'pyls' script to aid refactoring
* combine vertex, color, normals into single interleaved array,
* switch from vertex arrays to VBO objects
* move from using glVertexPointer, glColorPointer, glNormalPointer to using
  glVertexAttributePointer
* use vertex array object to reduce number of bind calls needed in inner
  render loop.
* Can binding the VBO itself go into the vertex array object? Y.
* use pyopengl shader management instead of our own compile/link code.
  Or improve our own shader management code to take uniforms, see:
    http://swiftcoder.wordpress.com/2008/12/19/simple-glsl-wrapper-for-pyglet/
* color in top level package
* add an example which allows browsing of a bestiary
* the regular solids
* try subdividing shapes with a new vertex in the middle of the face
* function to stellate a shape (either strict stellation, or else just replace
  each face with a pointy thing. The second seems both easier and more
  flexible - pointy could be varied in height, even made negative.
  (REPLACE the current subdivide_center with this - it is of little use for
  iterated application)
* decide what to do about uniformly dark faces on opposite side of polyhedra
  to the directional light source
* keypresses should map to invocation of a callable.
    * Callables to create basic shapes and add them to the world
    * Callables to modify the shape of the last-added item
        * subdivide, etc
    * Callables to change the colors
        * one random color all over
        * different random color for each face
* normalise the sizes of the basic shapes to all have verts at the given
  radius
* subdivide adds more vertices than it needs to: two at the midpoint of each
  edge (one for each adjacent face.)
* subdivide should work on faces with any number of edges.
  leave same shape as original in middle, surround it with triangles from
  cutting off each corner
* Startup: Replace the (* seq) operator on initialising gl_array in Glyph.
  Instead use:
    array = arraytype()
    array[:] = seq # eg. [11, 22, 33... ]
* creating a shape labels faces with 'Tetrahedron', etc
* or '?' if unknown
* Make sure all faces use same instance of the string
* change modifiers 'subdivide', 'stellate', 'normalize' to expose fn which
  operates on just a single given face, and to expose a function which
  operates on specified faces (specified as a list of integer face-indices.)
* change modifiers to append to face's label: 'Tetrahedron.subdivided-center'
* move centroid method to Face
* create functions to return list of face indices based on face labels
* rewrite DualTetrahedron to use the above faculty
* new modifier to extrude faces
* extrude center subdivisions
* extrude corner subdivisions
* stellate extrusion-ends
* browser demo should have keys to select face type, then other keys to operate
  on the selected faces
* color modifiers should operate on selected faces
* keypress to generate koche tetra and color it nicely
* face labelling:
    * label each face with a 'generation' count? Or a 'face type' UID, so that
      modifications could operate on just a subset of faces.
      * UID is bad because how to subsequent operations know which UID to
        operate on?
      * generation count is bad because subsequent operations could create#
        identical counts on very different faces
      * maybe each face has a list of operations that have been performed on it
        Tetrahedron:
            f0 [tetrahedron]
            f1 [tetrahedron]
            f2 [tetrahedron]
            f3 [tetrahedron]
        subdivide:
            f0.0 [tetrahedron,center]
            f0.1 [tetrahedron,corner]
            f0.2 [tetrahedron,corner]
            f0.3 [tetrahedron,corner]
            f1.0 [tetrahedron,center]
            f1.1 [tetrahedron,corner]
            f1.1 [tetrahedron,corner]
            f1.1 [tetrahedron,corner]
            etc
    * add shape modifiers that subdivide, then operate on just a subset of the
      new faces. Recreate Koche tetra using this.
* key to toggle cull backface?
* keys to zoom camera orbit in and out
* make camera zoom smooth
* Add good shapes from flyinghigh
* talk new draft
* finish documentation
    * patch sphinx-apidoc to not garble the user's specified --doc-header
    * move docs makefile into docs dir
    * figure out how to link to classes, modules, etc
    * add a worked example, with screenshots
    * add docstrings throughout
    * tidy the package / module / class API
    * can we include README.txt in the middle of intro.rst?
* eventloop in top level package? render? world? camera? what else?
* being added to the world converts shapes to glyphs, not being rendered.
* release on PyPI
    * create a local sdist
    * that can run
    * and that can install
    * check it includes the documentation, in documentation/html
    * upload to PyPI and repeat the above tests
    * run examples in isolation using the installed Gloopy
    * binary release not required (it's a library)
    * add a comment on pyweek message board
* totally rewrite shape_to_glyph algorithm, incorporating what Glyph then
  subsequently does with the outputs. Suspect we're
  doing too much work (e.g. vertex and index re-ordering)
* Combining the orientations of nested multishapes is done in an innefficient
  manner, multiplying every vertex by each multishape's orientation in
  series. Modify to calculate the cumulative orientation first, then
  multiply each vertex by the result.
* code to generate setup.py's package_data param
* fiddle with sizes of basic shapes so they interpenetrate interestingly
* demo: co-axial rings spinning at various speeds about the common axis
* Cube cluster generated from pixels of small bitmaps. Invader! Mario! etc.
* color should be a float throughout
* Allow each gameitem to specify its own shader program
    Requires some thought. Vertex attributes must match up with those
    expected by the shader. Probably this involves wrapping shaders inside
    Python source, which declares and exposes their attributes and uniforms.
* lighting is wrong! Stationary camera, spinning object, lighting stays fixed.
  Maybe compare my shader with the tutorial at:
  http://www.arcsynthesis.org/gltut/Illumination/Illumination.html
  Add a point light source while we're at it?
Windows:
    * python setup.py install
        y source
        y data
        y examples
        y runs
        y docs: in Lib/site-packages/gloopy/share/doc/gloopy
    * sdist (Manifest.in)
        y source
        y data
        y examples
        y docs: in docs/gloopy
    * install from sdist
        y source
        y data
        y examples
        y runs
        y docs: in Lib/site-packages/gloopy/share/doc/gloopy
    * register, upload
    * install from pypi
        y source
        y data
        y examples
        y runs
        y docs: in share/doc/gloopy
* use a function to generate data_files in setup.py
* prune (1Mb) .doctrees from documentation dir (pruned from sdist in manifest.in)

- put Curtis' OSX fixes into an OS abstraction module
- change of color from ubyte to float should have been encapsulated or
  DRY
- use an up-to-date pyglet
- space invaders don't work, at least on OSX
- numbering faces can't just use i and i+1: must use i and 
  _get_first_unused_cat()
  :known issue on pyglet 1.1.4 OSX, fixed in cytpes branch
- selecting faces +/- should not go beyond max/min
- backspace should be select none (no faces? or no item?)
- removing the last shape crashes rendering highlight with 'None' position
- Can browser.py color the currently selected faces? Instead of named, use
  integers and selection can then inc/dec to select various sets of faces.
